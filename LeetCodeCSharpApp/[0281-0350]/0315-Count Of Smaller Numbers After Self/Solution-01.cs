namespace LeetCodeCSharpApp.CountOfSmallerNumbersAfterSelf01;

/// <summary>
/// Merge sort (https://tinyurl.com/2s4jvx33)
/// </summary>
public class Solution
{
    public IList<int> CountSmaller(int[] nums)
    {
        if (nums == null || nums.Length == 0)
            return new List<int>();

        var n = nums.Length;
        var result = new int[n];

        (int val, int originalIdx)[] newNums = new (int, int)[n];
        for (var i = 0; i < n; ++i)
            newNums[i] = (nums[i], i);

        MergeSortAndCount(newNums, 0, n - 1, result);

        // notice we don't care about the sorted array after merge sort finishes.
        // we only wanted the result counts, generated by running merge sort
        var resultList = new LinkedList<int>();

        foreach (var i in result)
            resultList.AddLast(i);

        return resultList.ToList();
    }

    private static void MergeSortAndCount(IList<(int val, int originalIdx)> nums, int start, int end, IList<int> result)
    {
        if (start >= end)
            return;

        var mid = (start + end) / 2;
        MergeSortAndCount(nums, start, mid, result);
        MergeSortAndCount(nums, mid + 1, end, result);

        // left subarray start...mid
        // right subarray mid+1...end
        var leftPos = start;
        var rightPos = mid + 1;
        var merged = new LinkedList<(int val, int originalIdx)>();
        var numElemsRightArrayLessThanLeftArray = 0;

        while (leftPos < mid + 1 && rightPos <= end)
            if (nums[leftPos].val > nums[rightPos].val)
            {
                // this code block is exactly what the problem is asking us for:
                // a number from the right side of the original input array, is smaller
                // than a number from the left side
                //
                // within this code block,
                // nums[rightPos] is smaller than the start of the left sub-array.
                // Since left sub-array is already sorted,
                // nums[rightPos] must also be smaller than the entire remaining left sub-array
                ++numElemsRightArrayLessThanLeftArray;

                // continue with normal merge sort, merge
                merged.AddLast(nums[rightPos]);
                ++rightPos;
            }
            else
            {
                // a number from left side of array, is smaller than a number from
                // right side of array
                result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;

                // Continue with normal merge sort
                merged.AddLast(nums[leftPos]);
                ++leftPos;
            }

        // part of normal merge sort, if either left or right sub-array is not empty,
        // move all remaining elements into merged result
        while (leftPos < mid + 1)
        {
            result[nums[leftPos].originalIdx] += numElemsRightArrayLessThanLeftArray;

            merged.AddLast(nums[leftPos]);
            ++leftPos;
        }

        while (rightPos <= end)
        {
            merged.AddLast(nums[rightPos]);
            ++rightPos;
        }

        // part of normal merge sort
        // copy back merged result into array
        var pos = start;
        foreach (var m in merged)
        {
            nums[pos] = m;
            ++pos;
        }
    }
}
